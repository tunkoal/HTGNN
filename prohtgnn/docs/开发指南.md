# 开发文档（模块/接口与扩展指引）

> 下述接口说明与文件编号均对应本仓库，函数/类参数与默认值以源码为准。

---

## A. 运行主流程（`train.py`）

- **集中式配置**（顶部常量）：`OUTPUT_DIR/NODES_CSV/EDGES_CSV/SEED/DEVICE/TIME_WINDOW/D_MODEL/N_LAYERS/N_HEADS/DROPOUT/LR/WEIGHT_DECAY/EPOCHS/PATIENCE/CKPT`。固定随机种子 42；默认 `cuda:5`。  
- **main() 流程**：  
  1) `build_hetero_time_graph` 读数并构图 + 分层划分（返回 `G, y, split, meta, n_inp`），随后 `print_graph_report(meta)` 打印报表；  
  2) `ProteinBinaryClassifier` 初始化（自动对无特征类型注入嵌入）；  
  3) 训练循环（BCE with logits；验证集度量由 `compute_all_metrics` 计算），**每 10 epoch 打印**一行汇总；  
  4) `EarlyStopping` 触发后加载最优权重；  
  5) `plot_lines`/`plot_roc_pr` 保存 7 张图；  
  6) 打印**测试集（protein）**指标。

---

## B. 预处理（`preprocess.py`）

- `load_nodes(nodes_csv)` → `nodes_df, id2type, type2ids, labels_p`  
  - 将 `single protein→protein`；强制关键列为字符串；对 **protein** 从 `function` 生成二分类标签（`ORF-V`→1）。  
- `collect_boundaries_from_edges(edges_df)`  
  - 解析 `timeset` 端点，要求**唯一端点=37**（36 个时间片）。  
- `parse_timeset_to_slices(timeset, boundaries)`  
  - 把区间串解析为覆盖的时间片下标；半开 `[a,b)`；空值=全时段；带浮点容差。  
- `load_edges(edges_csv, id2type)` → `edges_df, boundaries, edges_per_t`  
  - 验证 `Directed/Undirected`；过滤不存在的节点；展开到各时间片。

---

## C. 构图与划分（`dataset.py`）

- `build_hetero_time_graph(nodes_csv, edges_csv)` → `G, y, split, meta, n_inp`  
  - **ID 连续化**：为每类型构建字符串 Id → 连续索引；  
  0  - **hetero_dict**：键为 `(srctype, f"{edge_type}_t{idx}", dsttype)`；**Undirected** 补反向；  
  - **节点特征**：所有类型的每个 `t*` 先置为 **1 维 0**，随后仅对 **protein** 填充 `nodes.csv` 的 `t0~t35`；返回 `n_inp=1`；  
  - **分层划分**：在 **protein** 上做 70/15/15 分层抽样（两段式 `StratifiedShuffleSplit`）；  
  - **报表元信息**：`type2num`、`base_rel_counts`（跨时去重，方向保留）、各划分索引与标签统计等。

> 注：“基础关系聚合计数”先在跨时间片维度做**有序唯一**去重，再按 `(srctype, base_rel, dsttype)` 统计，保证与报表一致。

---

## D. 模型（`model.py`）

### D.1 HTGNN 主干（与官方实现一致）
- **RelationAgg**：跨关系重要性权重（全局关系权重，softmax 归一化）  
- **TemporalAgg**：跨时间注意力 + 正/余弦位置编码（基数 1e5）  
- **HTGNNLayer**：Intra（GATConv）→ Inter（RelationAgg）→ Across‑time（TemporalAgg）→ 门控残差（可选 LayerNorm）  
- **HTGNN**：类型特定线性适配 → 堆叠 L 层 → **时间片求和**得到 `predict_type` 的最终表示（protein）

### D.2 任务封装：`ProteinBinaryClassifier`
- 自动为非 `protein` 类型注入 `nn.Embedding` 并在前向时覆盖各自 `t*` 特征；  
- 调用 `HTGNN(..., predict_type="protein")` 得到表示，再经两层 MLP 输出 1 维 logits。

---

## E. 指标与可视化（`metrics.py`）

- `compute_all_metrics(y_true, y_score, threshold=0.5)`：AUC、AP、ACC、BACC、F1(macro) 与**正/负类** Precision/Recall；单类 split 的 AUC/AP 兼容为 NaN。  
- `plot_lines(...)`、`plot_roc_pr(...)`：保存验证折线 5 张与测试 ROC/PR 2 张到 `outputs/`。

---

## F. 报表（`utils_report.py`）

- `print_graph_report(meta)`：严格按示例格式打印：  
  - `[Nodes]` 各类型数量与比例（固定顺序：GO、protein、reaction）；  
  - `[Labels on protein]` 正负与比例；  
  - `[Edges]` 基础关系聚合（去时间后缀，方向保留；固定展示顺序与对齐宽度）；  
  - `[Splits]` 各划分规模与**类内**比例（两位小数）。

---

## G. 早停（`utils/pytorchtools.py`）

- `EarlyStopping(patience, verbose, delta, path, trace_func)`：以**验证损失**触发；维护最优权重到 `path`。

---

## H. 扩展与二次开发

1. **多维时间特征**：若 `t0~t35` 为多维，可在 `dataset.py` 将 `n_inp=1` 改为实际维度；HTGNN 的 `adaption_layer` 会自动升维到 `d_model`。  
2. **更改时间窗口**：默认 36 片（由数据决定）；如需裁剪，可在 `train.py` 的 `TIME_WINDOW` 与 `model.HTGNN(...time_window=...)` 一致设置。  
3. **类别不平衡**：默认阈值 0.5；可外部进行阈值搜索或在训练时使用加权 BCE。  
4. **设备/路径**：在 `train.py` 顶部集中配置（不走命令行），便于审计与复现。

---

## I. 故障排查

- **timeset 唯一端点数 != 37** → 预处理抛错：确认端点数；空值=全时段。  
- **Directed/Undirected 之外的 Type** → 抛错：修正输入。  
- **protein 的 t* 缺失** → 抛错：补齐 `t0~t35`。  
- **GPU 不存在** → 修改 `train.py` 顶部 `DEVICE` 为 `cuda:0` 或 `cpu`。
